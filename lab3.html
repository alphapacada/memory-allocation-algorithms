<html>
<head>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" crossorigin="anonymous">
	<style type="text/css">

        .scroll-box {
            overflow-y: scroll;
            height: 200px;
          /*  padding: 1rem*/
        }
        .autoPadding {
        	margin: 15px
        }

	</style>
	<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
</head>
<body>

	<div class = "row" id="page-wrapper">
		<br>
        <h1 class = "col-md-12 text-center" style = "height: 100px; ">Placement Policies</h1>
        <br>
        <div class = "col-3">
            Upload Job list: 
            <input type="file" id="fileInput">
        </div>
       
        <div class = "col-3">
            Upload Memory list: 
            <input type="file" id="fileInput2">
        </div>
        
     
         <div class = "row col-12">
        	<div class="col-3"> side a
	  			<div class="card-header">
				    Job List
				  </div>
				  <div class="card-block scroll-box">
				    
				     <pre id = "fileDisplayArea"></pre>
				  </div>
			</div>
			<div class="col-3"> side b
	  			<div class="card-header" >
				    Memory List
				  </div>
				  <div class="card-block scroll-box">
				    
				     <pre id = "fileDisplayArea2"></pre>
				  </div>
			</div>
			 <div class=" col-6">
        			<div class = "row col-12">
        			<span class="col-6">
        				<h1 style="display:inline">Time : <h1 style="display:inline" id = "counter">0</h1></h1>
        				
        			</span>
        			<span class="col-6"><button id = "play"  class= "btn btn-primary">Play</button></span>
        		</div>
				 
			
			 
   
			<div class = "col-12" id = "tableContainer">
					<table id = "memTable" class="table table-inverse">
						<thead id ="tableHead">
							<tr>
								<th>Memory Partition</th>
								<th>Memory Size</th>
								<th>Job Number</th>
								<th>Job Size</th>
								<th>Time Remaining</th>
							</tr>
						</thead>
						<tbody id = "tableBody"></tbody>
					</table>
			</div>
	   </div>
        </div>
       
	
</div>
</body>
<script type="text/javascript">
window.onload = function() {
        $("#tables").hide()
        var fileInput = document.getElementById('fileInput');
        var fileDisplayArea = document.getElementById('fileDisplayArea');
        var fileDisplayArea2 = document.getElementById('fileDisplayArea2');
        var jobStream = []
        var jobTime = []
        var memory = []
        var sortedMemory = []
        var jobQueue = []
     	var assignedProcesses = []
     	var finishedProcesses = 0
     	var buffer = []
     	var time
     	var SPEED = 1000
     	var state = false
          var re = /\s+/
           //var state = 0
         fileInput.addEventListener('change', function(e) {
            var file = fileInput.files[0];
            var textType = /text.*/;
           
         

            if (file.type.match(textType)) {
                var reader = new FileReader();

                reader.onload = function(e) {
                	//console.log(this.result)
                    fileDisplayArea.innerText = reader.result;
                    var lines = this.result.split('\n');
                    //console.log(lines)
    				listParser("job", lines)
    				
    				startAllocation()
    				
                }



                reader.readAsText(file); 

                  

            } else {
                fileDisplayArea.innerText = "File not supported!"
            }
            
        });
           function print(message) {
        	//console.log(JSON.stringify(message))
        }
         fileInput2.addEventListener('change', function(e) {
            var file = fileInput2.files[0];
            var textType = /text.*/;
         

            if (file.type.match(textType)) {
                var reader2 = new FileReader();

                reader2.onload = function(e) {
                	//console.log(this.result)
               //console.log(reader2.result)
                    fileDisplayArea2.innerText = reader2.result;
                    var lines = this.result.split('\n');
                    //console.log(lines)
    				listParser("memory", lines)
    				startAllocation();
                }


                reader2.readAsText(file); 
                 
                  

            } else {
                fileDisplayArea2.innerText = "File not supported!"
            }
           
        });
         function startAllocation () {
         	if(memory.length!=0 && jobStream.length!=0) {
         		//firstFit(memory, jobStream)
         		//bestFit(memory, jobStream)
         		worstFit(memory, jobStream)
         	}
         }
         $("#play").click(function() {
         	var stop = $("#play").hasClass("btn-success")
         	if(stop) {
         		 $("#play").removeClass("btn-success")
         		 $("#play").addClass("btn-danger")
         		 state = false
         	} else {
         		state = true
         		 $("#play").removeClass("btn-danger")
         		$("#play").addClass("btn-success")
         		firstFit(memory, jobStream)
         	}
         })
         function toggleState() {
         	if(state== true) {
         		state = false
         	} else {
         		state = true
         	}
         }
         function listParser (listType, lines) {
         	if(listType == "job") {
         		for(var line = 1; line < lines.length; line++){
      					var word = lines[line];
      					word = word.split(re)
      					var job = {
      						number : parseInt(word[0]),
      						time : parseInt(word[1]),
      						size : parseInt(word[2])

      					}

      				jobStream.push(job)
      			}
         	}
         	if (listType == "memory") {
         		for(var line = 1; line < lines.length; line++){
      					var word = lines[line];
      					word = word.split(re)
      					var block = {
      						number : word[0],
      						size : word[1]

      					}

      				memory.push(block)
         	}

         }
     }

   async function firstFit(memory, jobStream) {
     	//i - jobStream counter
     	
     	time = 0 
     	var x = 0
     	var i = 0
     	var assigned = false
     	var excess = 0
     	
     	SPEED = 1000
     	var memoryCopy = memory.concat().sort(sortOnSize)
     	for(var i = 0; i < jobStream.length; i++) {
     		if(jobStream[i].size > memoryCopy[memoryCopy.length - 1].size) {
     			console.log("" + jobStream[i].size  + ">" + memoryCopy[memoryCopy.length -1].size)
     			excess++
     		}
     	}

     	//for(var i = 0; i < jobStream.length; i++) {
     //	while(i < jobStream.length) {
     		//if(state) {

     	//console.log("jobStream.length = " + jobStream.length)
     	while(finishedProcesses < jobStream.length - excess) {

     		i = 0
     		while(i < jobStream.length) {
     		//	console.log("finishedProcesses " + finishedProcesses[i])
     			
     			if(!assignedProcesses[i]) {
     			/*	console.log("current index = " + i)
	     			console.log("looping through buffer")*/
	     			for(var ctr = 0; ctr < buffer.length; ctr++) {

	     				var unassignedJob = buffer[ctr]
	     				//console.log("unassignedJob.number = " + unassignedJob.number)
	     				if(assignJob(unassignedJob.number-1)==true) {
	     					//finishedProcesses++
	     					//console.log("buffer job " + unassignedJob.number + " is finally allocated memory.")
	     					buffer.splice(unassignedJob.number-1) //remove from buffer if it is allocated with memory
	     				}
	     				
	     				
	     			}
	     			//console.log("now check next index")
	     			if(assignJob(i)==false) { //if next job is not allocated memory, add it to buffer
	     				//console.log("job " + i + "is not assigned so add to buffer")
	     				buffer.push( jobStream[ i ] ) 
	     			}else {
	     				//console.log("job " + i + "is allocated memory.")
	     				//finishedProcesses++
	     			}
	     			
	     			
			 	}
			 	i++ //move to the next job
			 }
			 	jobTime = updateRemainingTime(jobTime) //decrease time for occupying job
				time ++
	     		updateTable(time, jobQueue, memory, jobTime)
				await sleep(SPEED)
			 	
			 	console.log("" + finishedProcesses +" == " + jobStream.length)
	     		
     			}
     			
     			
     		
     			
     }
 
     			
     
     async function assignJob (i) {
     	var j = 0
     	var assigned = false

     	while (j < memory.length) {
     		if(!jobTime[j]) {
		     	jobTime[j] = {
		     		time: 0,
		     		number: null
		     	}
		     } 
 			if(jobTime[j].time == 0) { //no job exists
 				//console.log(" " + memory[j].size + " >= " + jobStream[i].size + " ?")
 				if(jobStream[i].size <= memory[j].size) {
 					//console.log("yes!")
 				}
	 			if(memory[j].size >= jobStream[i].size) { //check if memory can accommodate 
	 				assignedProcesses[i] = jobStream[i]
	 				//console.log("job" + jobStream[i].size + "can be assigned to memory " + memory[j].size)
	 				assigned = true
	 				x = j
	 				jobQueue[j] = jobStream[i]
	 				jobTime[j].time = jobStream[i].time
	 				jobTime[j].number = jobStream[i].number
	 				break;
					}
			}
     	j++
     	
		
     }

   
     return assigned;
     


 }
 async function assignJob2 (i) {
     	var j = 0
     	var assigned = false

     	console.log(sortedMemory.length)
     	while (j < sortedMemory.length) {
     		var origIdx = sortedMemory[j].number-1
     		if(!jobTime[origIdx]) {
		     	jobTime[origIdx] = {
		     		time: 0,
		     		number: null
		     	}
		     } 
 			if(jobTime[origIdx].time == 0) { //no job exists
 				//console.log(" " + memory[j].size + " >= " + jobStream[i].size + " ?")
 				if(jobStream[i].size <= memory[j].size) {
 					//console.log("yes!")
 				}
	 			if(sortedMemory[j].size >= jobStream[i].size) { //check if memory can accommodate 
	 				assignedProcesses[i] = jobStream[i]
	 				//console.log("job" + jobStream[i].size + "can be assigned to memory " + memory[j].size)
	 				console.log("" +sortedMemory[j].size + " = " + memory[sortedMemory[j].number -1].size)
	 				assigned = true
	 				x = j
	 				jobQueue[origIdx] = jobStream[i]
	 				jobTime[origIdx].time = jobStream[i].time
	 				jobTime[origIdx].number = jobStream[i].number
	 				break;
					}
			}
     	j++
     	
		
     }
     return assigned;
 }


     async function bestFit(memory, jobStream) {
     	//offset -->  current Index of memory
     	var assignedJob = []
     	var offset = 0
     	sortedMemory = JSON.parse(JSON.stringify(memory)).sort(sortOnSize)
     	console.log(sortedMemory)
     	
     	time = 0 
     	var x = 0
     	var i = 0
     	var assigned = false
     	var excess = 0
     	
     	SPEED = 1000
     	var memoryCopy = memory.concat().sort(sortOnSize)
     	for(var i = 0; i < jobStream.length; i++) {
     		if(jobStream[i].size > memoryCopy[memoryCopy.length - 1].size) {
     			console.log("" + jobStream[i].size  + ">" + memoryCopy[memoryCopy.length -1].size)
     			excess++
     		}
     	}
     	while(finishedProcesses < jobStream.length - excess) {

     		i = 0
     		while(i < jobStream.length) {
     		//	console.log("finishedProcesses " + finishedProcesses[i])
     			
     			if(!assignedProcesses[i]) {
     			/*	console.log("current index = " + i)
	     			console.log("looping through buffer")*/
	     			for(var ctr = 0; ctr < buffer.length; ctr++) {

	     				var unassignedJob = buffer[ctr]
	     				//console.log("unassignedJob.number = " + unassignedJob.number)
	     				if(assignJob2(unassignedJob.number-1)==true) {
	     					//finishedProcesses++
	     					//console.log("buffer job " + unassignedJob.number + " is finally allocated memory.")
	     					buffer.splice(unassignedJob.number-1) //remove from buffer if it is allocated with memory
	     				}
	     				
	     				
	     			}
	     			if(assignJob2(i)==false) { 
	     				buffer.push( jobStream[ i ] ) 
	     			}else {
	     			}

			 	}
			 	i++ //move to the next job
			 }
			 	jobTime = updateRemainingTime(jobTime) //decrease time for occupying job
				time ++
	     		updateTable(time, jobQueue, memory, jobTime)
				await sleep(SPEED)
			 	
			 
     			}
     			
     			
 }
 async function worstFit() {
 	var assignedJob = []
     	var offset = 0
     	sortedMemory = JSON.parse(JSON.stringify(memory)).sort(sortOnSizeDec)
     	console.log(sortedMemory)
     	
     	time = 0 
     	var x = 0
     	var i = 0
     	var assigned = false
     	var excess = 0
     	
     	SPEED = 1000
     	var memoryCopy = memory.concat().sort(sortOnSize)
     	for(var i = 0; i < jobStream.length; i++) {
     		if(jobStream[i].size > memoryCopy[memoryCopy.length - 1].size) {
     			console.log("" + jobStream[i].size  + ">" + memoryCopy[memoryCopy.length -1].size)
     			excess++
     		}
     	}
     	while(finishedProcesses < jobStream.length - excess) {

     		i = 0
     		while(i < jobStream.length) {
     		//	console.log("finishedProcesses " + finishedProcesses[i])
     			
     			if(!assignedProcesses[i]) {
     			/*	console.log("current index = " + i)
	     			console.log("looping through buffer")*/
	     			for(var ctr = 0; ctr < buffer.length; ctr++) {

	     				var unassignedJob = buffer[ctr]
	     				//console.log("unassignedJob.number = " + unassignedJob.number)
	     				if(assignJob2(unassignedJob.number-1)==true) {
	     					//finishedProcesses++
	     					//console.log("buffer job " + unassignedJob.number + " is finally allocated memory.")
	     					buffer.splice(unassignedJob.number-1) //remove from buffer if it is allocated with memory
	     				}
	     				
	     				
	     			}
	     			if(assignJob2(i)==false) { 
	     				buffer.push( jobStream[ i ] ) 
	     			}else {
	     			}

			 	}
			 	i++ //move to the next job
			 }
			 	jobTime = updateRemainingTime(jobTime) //decrease time for occupying job
				time ++
	     		updateTable(time, jobQueue, memory, jobTime)
				await sleep(SPEED)
			 	
			 
     			}
     			
     			
 }
    var sortOnOrder = function (a,b) {
    	return a.number - b.number
    }
    var sortOnSize = function (a,b) { //to sort memory
		return a.size- b.size
	}
	var sortOnSizeDec = function (a, b) {
		return b.size - a.size
	}
     function updateRemainingTime(jobTime) {

     	for(var i = 0; i < jobTime.length; i++) {
     		if(jobTime[i].time >0) {
     			jobTime[i].time --		
     		} 
     		if(jobTime[i].time == 0 && jobTime[i].number!=null) {
     				finishedProcesses++
     				jobTime[i].number = null
     		}
     	}
     	return jobTime
     }
     function decreaseRemainingTime(job) {
     	if(job.time > 0) {
     		job.time--

     	}
     	
     	
     	return job
     }
     function sleep(ms) {
     	return new Promise(resolve => setTimeout(resolve, ms));
     }
     function updateTable(time, jobQueue, memory, jobTime) {
     	$("#counter").html(time)
     	$("#tableBody").empty()
    
     		for(var i = 0; i < memory.length; i++) {
     			var job = jobQueue[i]
     			if(!job) { //default value
     				job = {
     					number:'',
     					size:''
     				}
     			}
     			//console.log(job)
     			var tr = document.createElement('tr')
     			$(tr).append('<th scope = "row">'+ memory[i].number + 'K</th>')//name
     			$(tr).append('<td>'+ memory[i].size + 'K</td>') //size
     			$(tr).append('<td>'+ job.number + '</td>') //name
     			$(tr).append('<td>'+ job.size + 'K</d>') //size
     			$(tr).append('<td>'+ jobTime[i].time + 's</d>') //time remaining
     			$("#tableBody").append(tr)

     		}
        	
      
     }
 }
</script>
</html>